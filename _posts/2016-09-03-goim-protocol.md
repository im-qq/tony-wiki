---
layout: inner
position: right
title: 'goim 协议详解'
date: 2016-06-07 01:39:00
categories: development
tags: goim
featured_image: ''
project_link: ''
button_icon: 'github'
button_text: 'Visit Project'
lead_text: 'goim'
---

# goim 协议详解

---

## 协议：

| PacketLen | HeaderLen | Version | Operation | Sequence |   Body   |
| :----: | :----: | :----: |:-------:| :-------------:|
| 4bytes  | 2bytes | 2bytes |  4bytes  | 4bytes | PacketLen - HeaderLen |

## 含义：

	PacketLen 包长度，在数据流传输过程中，先写入整个包的长度，方便整个包的数据读取。
	HeaderLen 头长度，在处理数据时，会先解析头部，可以知道具体业务操作。
	Version 协议版本号，主要用于上行和下行数据包按版本号进行解析。
	Operation 业务操作码，可以按操作码进行分发数据包到具体业务当中。
	Sequence 序列号，数据包的唯一标记，可以做具体业务处理，或者数据包去重。
	Body 实际业务数据，在业务层中会进行数据解码和编码。

## 解码
	
	comet -> logic

	comet 数据包会从长连接进行读取，在这层只进行数据包头部内容解析，然后根据[操作码]转发到各个业务操作，通过rpc传数据到logic层中。
	logic 通过rpc传输到logic层，会根据[具体业务]和[数据包版本]进行解码为实际数据对象，然后完成业务处理。

## 编码

	logic -> job -> comet

	以我目前的理解，解码在logic中完成，然而地说编码也应该在logic层完成；当发送一条消息时，会按格式进行编码放到body内容当中，消息生产发送到kafka，然后通过job进行消费推送消息到某个在comet上面的用户，通过socket传输到客户端当中。

## 授权

	在消息系统当中，第一个数据包莫过于连接授权；一般用户先通过https进行登录到业务系统中，得到token令牌，然后再和消息系统进行建立长连接。通常会设计成userId、token、protover，使用用户ID和token进行授权，protover为客户端支持的协议版本号。服务端可以通过protover知道客户端所支持的协议版本，可以下发所支持的数据版本内容。

## 协议升级

	在goim协议中，服务端和客户端都可以对等解析数据包，可以通过数据包ver字段进行对等解析。比如，我们客户端数据包升级，只需要把ver=2，再编码新版本数据内容再传给服务端；服务端可以支持ver=1和ver=2两种数据包版本进行解析，既可以完成协议兼容。如果服务端升级数据包版本，这时候需要客户端先支持解析版本才可以达到解码，此时可以通过建立连接时的protover知道客户端协议版本是否支持该数据版本，如果客户端不支持时可以下发老版本包内容，对支持新数据包客户端下发新的内容。

## 数据压缩

	一般我们只对某些比较大的数据包进行压缩，我们也应该要支持压缩和非压缩的数据包；在压缩过程只是对body内容进行压缩，会大大地减少数据包的体积，在传输过程可以达到更快、更小，服务端可以减少很多流量，然而当网卡到瓶颈时可以地达到更高的负载能力。这时候只需要下发ver=1和ver=2区分两种数据包给客户端解码就可以了。

## 同步协议

	当然，goim协议是完全地支持同步协议与客户端交互的，只是业务上面处理理念和直接推送消息有些不同。如何去理解所谓的同步协议？其实很简单，也就是服务端不进行消息的直接推送，只是推送一个最新的消息序列号给客户端，通过序列号客户端可以进行消息的同步和聚合下发。这时候消息系统就会变得非常轻量，只是实时传输一个同步序列号给客户端即可。不管客户端通过长连接还是短连接都可以通过业务方式去同步消息，并且很好地解决消息丢失或者回执消息的复杂过程。在客户端接收到每个消息序列号时，客户端发起一次消息同步去获取这个序列号之上的消息回来，可能会连续接收到新的消息序列号，但是只需要客户端记住该最新的序列号，发起每次请求时，都可以判断是否已经完全同步完最新的消息回来，客户端每次发起同步时都等待和超时完成这次同步时，才会进行一下次的消息同步。

## 客户端

	与服务端建立长连接后，其实是一个socket连接，只有二进制数据流的概念。客户端解析时需要单个数据包进行解析，这里客端可以先读取一个数据包头部内容，得到整个包长度后再进行读取完整的数据包。在进行socket读写时都会受到tcp窗口的buff限制，也有可能出现阻塞过程。所以我们客户端解析时，应该整个包完整长度的读取。整个过程分为：读取头部->读取数据内容->读取头部->读取数据内容。

